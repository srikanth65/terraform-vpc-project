name: Terraform CI/CD Pipeline

on:
  push:
    branches: [main, develop]
    paths: ['environments/**', 'modules/**']
  pull_request:
    branches: [main]
    paths: ['environments/**', 'modules/**']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options: [dev, stage, prod]
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options: [plan, apply, destroy]

env:
  TF_VERSION: '1.6.0'

permissions:
  id-token: write
  contents: read
  pull-requests: write

jobs:
  quality-checks:
    name: Quality & Security Checks
    runs-on: ubuntu-latest
    outputs:
      environments: ${{ steps.detect-changes.outputs.environments }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Detect Changed Environments
      id: detect-changes
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          echo "environments=[\"${{ github.event.inputs.environment }}\"]" >> $GITHUB_OUTPUT
        else
          changed_envs=$(git diff --name-only ${{ github.event.before }}..${{ github.sha }} | grep "environments/" | cut -d'/' -f2 | sort -u | jq -R -s -c 'split("\n")[:-1]')
          if [ "$changed_envs" == "[]" ] || [ -z "$changed_envs" ]; then
            echo "environments=[\"dev\"]" >> $GITHUB_OUTPUT
          else
            echo "environments=$changed_envs" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Terraform Format Check
      run: |
        terraform fmt -check -recursive
        if [ $? -ne 0 ]; then
          echo "‚ùå Terraform files are not properly formatted"
          echo "Run: terraform fmt -recursive"
          exit 1
        fi
        echo "‚úÖ All Terraform files are properly formatted"

    - name: Terraform Validate
      run: |
        for env in environments/*/; do
          echo "Validating $env"
          cd "$env"
          terraform init -backend=false
          terraform validate
          cd - > /dev/null
        done

    - name: Checkov Security Scan
      run: |
        pip install checkov
        checkov -d . --framework terraform --config-file .checkov.yml --compact || echo "Checkov completed"

    - name: TFLint
      uses: terraform-linters/setup-tflint@v4
      with:
        tflint_version: latest

    - name: Run TFLint
      run: |
        tflint --init
        tflint --recursive || echo "TFLint completed"

    - name: TFSec Security Scan
      run: |
        curl -s https://api.github.com/repos/aquasecurity/tfsec/releases/latest \
        | grep "browser_download_url.*linux-amd64" \
        | cut -d '"' -f 4 \
        | head -1 \
        | xargs wget -O tfsec
        chmod +x tfsec
        ./tfsec . || echo "TFSec completed"

  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: quality-checks
    if: always() && needs.quality-checks.result == 'success'
    strategy:
      matrix:
        environment: ${{ fromJson(needs.quality-checks.outputs.environments) }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-2

    - name: Terraform Init
      working-directory: ./environments/${{ matrix.environment }}
      run: terraform init

    - name: Terraform Plan
      working-directory: ./environments/${{ matrix.environment }}
      run: |
        terraform plan -var-file="terraform-${{ matrix.environment }}.tfvars" -out=tfplan
        terraform show -json tfplan > plan.json

    - name: Upload Plan
      uses: actions/upload-artifact@v4
      with:
        name: tfplan-${{ matrix.environment }}
        path: |
          ./environments/${{ matrix.environment }}/tfplan
          ./environments/${{ matrix.environment }}/plan.json

    - name: Plan Summary
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      with:
        script: |
          const fs = require('fs');
          const plan = JSON.parse(fs.readFileSync('./environments/${{ matrix.environment }}/plan.json', 'utf8'));
          
          const summary = {
            add: plan.resource_changes?.filter(r => r.change.actions.includes('create')).length || 0,
            change: plan.resource_changes?.filter(r => r.change.actions.includes('update')).length || 0,
            destroy: plan.resource_changes?.filter(r => r.change.actions.includes('delete')).length || 0
          };

          const comment = `## Terraform Plan Summary - ${{ matrix.environment }}
          
          üìä **Changes**: ${summary.add} to add, ${summary.change} to change, ${summary.destroy} to destroy
          
          <details>
          <summary>View Plan Details</summary>
          
          \`\`\`
          ${plan.resource_changes?.map(r => `${r.change.actions[0]}: ${r.address}`).join('\n') || 'No changes'}
          \`\`\`
          </details>`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [quality-checks, plan]
    if: |
      always() && 
      needs.quality-checks.result == 'success' && 
      needs.plan.result == 'success' &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') && 
      github.event_name == 'push' &&
      (contains(needs.quality-checks.outputs.environments, 'dev') || github.event.inputs.environment == 'dev')
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-2

    - name: Download Plan
      uses: actions/download-artifact@v4
      with:
        name: tfplan-dev
        path: ./environments/dev

    - name: Terraform Init
      working-directory: ./environments/dev
      run: terraform init

    - name: Terraform Apply
      working-directory: ./environments/dev
      run: terraform apply tfplan

  deploy-stage:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [quality-checks, plan, deploy-dev]
    if: |
      always() && 
      needs.quality-checks.result == 'success' && 
      needs.plan.result == 'success' &&
      (needs.deploy-dev.result == 'success' || needs.deploy-dev.result == 'skipped') &&
      github.ref == 'refs/heads/main' && 
      github.event_name == 'push' &&
      (contains(needs.quality-checks.outputs.environments, 'stage') || github.event.inputs.environment == 'stage')
    environment: stage
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-2

    - name: Download Plan
      uses: actions/download-artifact@v4
      with:
        name: tfplan-stage
        path: ./environments/stage

    - name: Terraform Init
      working-directory: ./environments/stage
      run: terraform init

    - name: Terraform Apply
      working-directory: ./environments/stage
      run: terraform apply tfplan

  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [quality-checks, plan, deploy-stage]
    if: |
      always() && 
      needs.quality-checks.result == 'success' && 
      needs.plan.result == 'success' &&
      needs.deploy-stage.result == 'success' &&
      github.ref == 'refs/heads/main' && 
      github.event_name == 'push' &&
      (contains(needs.quality-checks.outputs.environments, 'prod') || github.event.inputs.environment == 'prod')
    environment: production
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-2

    - name: Download Plan
      uses: actions/download-artifact@v4
      with:
        name: tfplan-prod
        path: ./environments/prod

    - name: Terraform Init
      working-directory: ./environments/prod
      run: terraform init

    - name: Terraform Apply
      working-directory: ./environments/prod
      run: terraform apply tfplan

  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: [deploy-dev, deploy-stage, deploy-prod]
    if: always() && (needs.deploy-dev.result == 'success' || needs.deploy-stage.result == 'success' || needs.deploy-prod.result == 'success')
    
    steps:
    - name: Slack Notification - Success
      env:
        SLACK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      run: |
        if [ -n "$SLACK_URL" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"‚úÖ Infrastructure deployment successful!"}' \
            "$SLACK_URL"
        fi

  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    needs: [quality-checks, plan, deploy-dev, deploy-stage, deploy-prod]
    if: always() && (needs.quality-checks.result == 'failure' || needs.plan.result == 'failure' || needs.deploy-dev.result == 'failure' || needs.deploy-stage.result == 'failure' || needs.deploy-prod.result == 'failure')
    
    steps:
    - name: Slack Notification - Failure
      env:
        SLACK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      run: |
        if [ -n "$SLACK_URL" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"‚ùå Infrastructure deployment failed! Check logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"}' \
            "$SLACK_URL"
        fi
